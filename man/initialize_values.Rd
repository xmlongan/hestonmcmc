% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R, R/initialize_values.R
\name{cinitialize_values}
\alias{cinitialize_values}
\alias{initialize_values}
\title{Initialize the Latent Volatility and Parameters}
\usage{
cinitialize_values(y, parameters, h)

initialize_values(y, parameters = c(0, 0.01, 0.1, 0.01, 0), h = 1)
}
\arguments{
\item{y}{vector of returns [\eqn{y_1, ..., y_N}].}

\item{parameters}{vector of parameters \eqn{(\mu,k,\theta,\sigma_v,\rho)}.}

\item{h}{time unit.}
}
\value{
a list with two elements, one vector of all parameters, and another
vector of the latent volatility.
}
\description{
Initialize the latent volatility and parameters with a good guess. Making
sure the initialized volatility are positive.
\itemize{
\item \code{cinitialize_values()} implemented in C++, through package Rcpp, returns a
vector of volatility, the outside \code{parameters} changes along with the
initialization inside the function.
\item \code{initialize_values()} implemented in R.
}
}
\details{
Parameters are first initialized. The volatility starting
point \eqn{v_0} is set to the long-run mean of volatility, \eqn{\theta}.
Then we use \eqn{P(v_n|v_{n-1},y_n)} to sample \eqn{v_n} iteratively.
However, we may end up some non-positive volatility because of using the
discretized Heston SV model, i.e.,
\deqn{y_n=\mu h -\frac{1}{2}v_{n-1}h + \sqrt{v_{n-1}h}\epsilon_n^y,}
\deqn{v_n-v_{n-1}=k(\theta-v_{n-1})h + \sigma_v\sqrt{v_{n-1}h}\epsilon_n^v.}
The conditional distribution
\deqn{P(v_n|v_{n-1},y_n)\sim\mathcal{N}
      (v_{n-1}+k(\theta-v_{n-1})h + \sigma_v\rho\sqrt{v_{n-1}h}\epsilon_n^y,
       \sigma_v^2(1-\rho^2)v_{n-1}h)}
where \deqn{\sqrt{v_{n-1}h}\epsilon_n^y = y_n-\mu h + \frac{1}{2}v_{n-1}h.}
If that does happen, we make a change as
\deqn{v_n =
      \begin{cases}
       v_n|v_{n-1},y_n & \text{if } v_n|v_{n-1},y_n > 0,\\
       0.00001         & \text{if } v_n|v_{n-1},y_n \le 0.
      \end{cases}}
}
\examples{
y = rep(0.125,4)
parameters_v = initialize_values(y)
}
